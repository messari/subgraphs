# Subgraph Schema: Lending Protocol (Extended)
# Version: 2.0.1
# See https://github.com/messari/subgraphs/blob/master/docs/SCHEMA.md for details

enum Network {
  ARBITRUM_ONE
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC # aka BNB Chain
  CELO
  COSMOS
  CRONOS
  MAINNET # Ethereum Mainnet
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC # aka Polygon
  XDAI # aka Gnosis Chain
}

enum ProtocolType {
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  GENERIC
  # Will add more
}

type Token @entity {
  " Smart contract address of the token "
  id: ID!

  " Name of the token, mirrored from the smart contract "
  name: String!

  " Symbol of the token, mirrored from the smart contract "
  symbol: String!

  " The number of decimal places this token uses, default to 18 "
  decimals: Int!

  " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal

  " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt
}

enum RewardTokenType {
  " For reward tokens awarded to LPs/lenders "
  DEPOSIT

  " For reward tokens awarded to borrowers "
  BORROW
}

type RewardToken @entity {
  " { Reward token type }-{ Smart contract address of the reward token } "
  id: ID!

  " Reference to the actual token "
  token: Token!

  " The type of the reward token "
  type: RewardTokenType!
}

enum LendingType {
  " Collateralized Debt Position (CDP) protocols have singular isolated positions created by users. We aggregate them to give a single view of a market "
  CDP

  " Pooled protocols pool all users assets into a single market "
  POOLED
}

enum RiskType {
  " Global risk means each users position in a market is combined for one score to determine if they can be liquidated "
  GLOBAL

  " Isolated risk means each users position in a market or CDP is isolated for risk of liquidation "
  ISOLATED
}

enum InterestRateType {
  " Stable interest rate (e.g. Aave) "
  STABLE

  " Variable interest rate (e.g. Compound) "
  VARIABLE

  " Fixed interest rate (e.g. Notional) "
  FIXED
}

enum InterestRateSide {
  " Interest rate accrued by lenders "
  LENDER

  " Interest rate paid by borrowers "
  BORROWER
}

enum PositionSide {
  " Position opened as a lender "
  LENDER

  " Position opened as a borrower "
  BORROWER
}

# Most markets only have a single interest rate given a specific type.
# However, fixed term lending protocols can have multiple rates with
# different duration/maturity per market. You can append a counter
# to the IDs to differentiate.
type InterestRate @entity {
  " { Interest rate side }-{ Interest rate type }-{ Market ID } "
  id: ID!

  " Interest rate in percentage APY. E.g. 5.21% should be stored as 5.21 "
  rate: BigDecimal!

  " Duration of the loan in days. Only applies to fixed term lending (e.g. Notional) "
  duration: Int

  " Maturity of the loan in block height. Only applies to fixed term lending (e.g. Notional) "
  maturityBlock: BigInt

  " The party the interest is paid to / received from "
  side: InterestRateSide!

  " The type of interest rate (e.g. stable, fixed, variable, etc) "
  type: InterestRateType!
}

#############################
##### Protocol Metadata #####
#############################

interface Protocol {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, etc) "
  type: ProtocolType!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Total number of pools "
  totalPoolCount: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]!
    @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]!
    @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")
}

type LendingProtocol implements Protocol @entity {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Aave v2 "
  name: String!

  " Slug of protocol, including version. e.g. aave-v2 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, etc) "
  type: ProtocolType!

  " The specific lending protocol type "
  lendingType: LendingType

  " Risk type of the lending protocol "
  riskType: RiskType

  " Tokens that can be minted. Only applies to CDP "
  mintedTokens: [Token!]

  ##### Quantitative Data #####

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Number of cumulative depositors "
  cumulativeUniqueDepositors: Int!

  " Number of cumulative borrowers "
  cumulativeUniqueBorrowers: Int!

  " Number of cumulative liquidators (accounts that performed liquidation) "
  cumulativeUniqueLiquidators: Int!

  " Number of cumulative liquidatees (accounts that got liquidated) "
  cumulativeUniqueLiquidatees: Int!

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Current balance of all deposited assets, in USD. Note this metric should be the same as TVL. "
  totalDepositBalanceUSD: BigDecimal!

  " Sum of all historical deposits in USD (only considers deposits and not withdrawals) "
  cumulativeDepositUSD: BigDecimal!

  " Current balance of all borrowed/minted assets (not historical cumulative), in USD. "
  totalBorrowBalanceUSD: BigDecimal!

  " Sum of all historical borrows/mints in USD (i.e. total loan origination). "
  cumulativeBorrowUSD: BigDecimal!

  " Sum of all historical liquidations in USD "
  cumulativeLiquidateUSD: BigDecimal!

  " Total supply of minted tokens in native amounts, with same ordering as mintedTokens. Only applies to CDP "
  mintedTokenSupplies: [BigInt!]

  " Total number of pools "
  totalPoolCount: Int!

  " Total number of open positions "
  openPositionCount: Int!

  " Total number of positions (open and closed) "
  cumulativePositionCount: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]!
    @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]!
    @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")

  ##### Markets #####

  " All markets that belong to this protocol "
  markets: [Market!]! @derivedFrom(field: "protocol")
}

###############################
##### Protocol Timeseries #####
###############################

type UsageMetricsDailySnapshot @entity {
  " ID is # of days since Unix epoch time "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: LendingProtocol!

  " Number of unique daily active users "
  dailyActiveUsers: Int!

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Number of unique daily depositors "
  dailyActiveDepositors: Int!

  " Number of cumulative depositors "
  cumulativeUniqueDepositors: Int!

  " Number of unique daily borrowers "
  dailyActiveBorrowers: Int!

  " Number of cumulative borrowers "
  cumulativeUniqueBorrowers: Int!

  " Number of unique daily liquidators (accounts that performed liquidation) "
  dailyActiveLiquidators: Int!

  " Number of cumulative liquidators (accounts that performed liquidation) "
  cumulativeUniqueLiquidators: Int!

  " Number of unique daily liquidatees (accounts that got liquidated) "
  dailyActiveLiquidatees: Int!

  " Number of cumulative liquidatees (accounts that got liquidated) "
  cumulativeUniqueLiquidatees: Int!

  " Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. "
  dailyTransactionCount: Int!

  " Total number of deposits in a day "
  dailyDepositCount: Int!

  " Total number of withdrawals in a day "
  dailyWithdrawCount: Int!

  " Total number of borrows/mints in a day "
  dailyBorrowCount: Int!

  " Total number of repayments/burns in a day "
  dailyRepayCount: Int!

  " Total number of liquidations in a day "
  dailyLiquidateCount: Int!

  " Total number of pools "
  totalPoolCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type UsageMetricsHourlySnapshot @entity {
  " { # of hours since Unix epoch time } "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: LendingProtocol!

  " Number of unique hourly active users "
  hourlyActiveUsers: Int!

  " Number of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. "
  hourlyTransactionCount: Int!

  " Total number of deposits in an hour "
  hourlyDepositCount: Int!

  " Total number of withdrawals in an hour "
  hourlyWithdrawCount: Int!

  " Total number of borrows/mints in an hour "
  hourlyBorrowCount: Int!

  " Total number of repayments/burns in an hour "
  hourlyRepayCount: Int!

  " Total number of liquidations in an hour "
  hourlyLiquidateCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type FinancialsDailySnapshot @entity {
  " ID is # of days since Unix epoch time "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: LendingProtocol!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Total supply of minted tokens in native amounts, with same ordering as mintedTokens. Only applies to CDP "
  mintedTokenSupplies: [BigInt!]

  ##### Revenue #####

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  dailySupplySideRevenueUSD: BigDecimal!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  dailyTotalRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  ##### Lending Activities #####

  " Current balance of all deposited assets, in USD. Note this metric should be the same as TVL. "
  totalDepositBalanceUSD: BigDecimal!

  " Total assets deposited on a given day, in USD "
  dailyDepositUSD: BigDecimal!

  " Sum of all historical deposits in USD (only considers deposits and not withdrawals) "
  cumulativeDepositUSD: BigDecimal!

  " Current balance of all borrowed/minted assets, in USD. "
  totalBorrowBalanceUSD: BigDecimal!

  " Total assets borrowed/minted on a given day, in USD. "
  dailyBorrowUSD: BigDecimal!

  " Sum of all historical borrows/mints in USD (i.e. total loan origination). "
  cumulativeBorrowUSD: BigDecimal!

  " Total assets liquidated on a given day, in USD. "
  dailyLiquidateUSD: BigDecimal!

  " Sum of all historical liquidations in USD "
  cumulativeLiquidateUSD: BigDecimal!

  " Total assets withdrawn on a given day, in USD. "
  dailyWithdrawUSD: BigDecimal!

  " Total assets repaid on a given day, in USD. "
  dailyRepayUSD: BigDecimal!
}

###############################
##### Pool-Level Metadata #####
###############################

type Market @entity {
  " Smart contract address of the market "
  id: ID!

  " The protocol this pool belongs to "
  protocol: LendingProtocol!

  " Name of market "
  name: String

  " Is this market active or is it frozen "
  isActive: Boolean!

  " Can you use the output token as collateral "
  canUseAsCollateral: Boolean!

  " Can you borrow from this market "
  canBorrowFrom: Boolean!

  " Maximum loan-to-value ratio as a percentage value (e.g. 75% for DAI in Aave) "
  maximumLTV: BigDecimal!

  " Liquidation threshold as a percentage value (e.g. 80% for DAI in Aave). When it is reached, the position is defined as undercollateralised and could be liquidated "
  liquidationThreshold: BigDecimal!

  " Liquidation penalty (or the liquidation bonus for liquidators) as a percentage value. It is the penalty/bonus price on the collateral when liquidators purchase it as part of the liquidation of a loan that has passed the liquidation threshold "
  liquidationPenalty: BigDecimal!

  " Token that need to be deposited to take a position in protocol "
  inputToken: Token!

  " Token that is minted to track ownership of position in protocol (e.g. aToken, cToken). Leave as null if doesn't exist "
  outputToken: Token

  " Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon "
  rewardTokens: [RewardToken!]

  ##### Quantitative Data #####

  " All interest rates / fees allowed in the market. Interest rate should be in APY percentage "
  rates: [InterestRate!]!

  " Current TVL (Total Value Locked) of this market "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the market, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the market, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the market. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Current balance of all deposited assets (not historical cumulative), in USD "
  totalDepositBalanceUSD: BigDecimal!

  " Sum of all historical deposits in USD (only considers deposits and not withdrawals) "
  cumulativeDepositUSD: BigDecimal!

  " Current balance of all borrowed/minted assets (not historical cumulative), in USD "
  totalBorrowBalanceUSD: BigDecimal!

  " Sum of all historical borrows/mints in USD (i.e. total loan origination) "
  cumulativeBorrowUSD: BigDecimal!

  " Sum of all historical liquidations in USD "
  cumulativeLiquidateUSD: BigDecimal!

  ##### Token Balances #####

  " Amount of input tokens in the market "
  inputTokenBalance: BigInt!

  " Price per share of input token in USD "
  inputTokenPriceUSD: BigDecimal!

  " Total supply of output token "
  outputTokenSupply: BigInt!

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal!

  " Amount of input token per full share of output token. Only applies when the output token exists (note this is a ratio and not a percentage value, i.e. 1.05 instead of 105%) "
  exchangeRate: BigDecimal

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]

  " Creation timestamp "
  createdTimestamp: BigInt!

  " Creation block number "
  createdBlockNumber: BigInt!

  ##### Account/Position Data #####

  " All positions in this market "
  positions: [Position!]! @derivedFrom(field: "market")

  " Number of positions in this market "
  positionCount: Int!

  " Number of open positions in this market "
  openPositionCount: Int!

  " Number of closed positions in this market "
  closedPositionCount: Int!

  " Number of lending positions in this market "
  lendingPositionCount: Int!

  " Number of borrowing positions in this market "
  borrowingPositionCount: Int!

  ##### Snapshots #####

  " Market daily snapshots "
  dailySnapshots: [MarketDailySnapshot!]! @derivedFrom(field: "market")

  " Market hourly snapshots "
  hourlySnapshots: [MarketHourlySnapshot!]! @derivedFrom(field: "market")

  ##### Events #####

  " All deposits made to this market "
  deposits: [Deposit!]! @derivedFrom(field: "market")

  " All withdrawals made from this market "
  withdraws: [Withdraw!]! @derivedFrom(field: "market")

  " All borrows from this market "
  borrows: [Borrow!]! @derivedFrom(field: "market")

  " All repayments to this market "
  repays: [Repay!]! @derivedFrom(field: "market")

  " All liquidations made to this market "
  liquidates: [Liquidate!]! @derivedFrom(field: "market")
}

#################################
##### Pool-Level Timeseries #####
#################################

type MarketDailySnapshot @entity {
  " { Smart contract address of the market }-{ # of days since Unix epoch time } "
  id: ID!

  " The protocol this snapshot belongs to "
  protocol: LendingProtocol!

  " The pool this snapshot belongs to "
  market: Market!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " All interest rates / fees allowed in the market. Interest rate should be in APY percentage "
  rates: [InterestRate!]!

  " Current TVL (Total Value Locked) of this market "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the market, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Daily revenue generated by the market, accrued to the supply side. "
  dailySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the market, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Daily revenue generated by the market, accrued to the protocol. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the market. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Daily revenue generated by the market. "
  dailyTotalRevenueUSD: BigDecimal!

  " Current balance of all deposited assets (not historical cumulative), in USD. Same as pool TVL. "
  totalDepositBalanceUSD: BigDecimal!

  " Sum of all deposits made on a given day, in USD "
  dailyDepositUSD: BigDecimal!

  " Sum of all historical deposits in USD (only considers deposits and not withdrawals) "
  cumulativeDepositUSD: BigDecimal!

  " Current balance of all borrowed/minted assets (not historical cumulative), in USD. "
  totalBorrowBalanceUSD: BigDecimal!

  " Sum of all borrows/mints made on a given day, in USD "
  dailyBorrowUSD: BigDecimal!

  " Sum of all historical borrows/mints in USD (i.e. total loan origination) "
  cumulativeBorrowUSD: BigDecimal!

  " Total assets liquidated on a given day, in USD. "
  dailyLiquidateUSD: BigDecimal!

  " Sum of all historical liquidations in USD "
  cumulativeLiquidateUSD: BigDecimal!

  " Total assets withdrawn on a given day, in USD. "
  dailyWithdrawUSD: BigDecimal!

  " Total assets repaid on a given day, in USD. "
  dailyRepayUSD: BigDecimal!

  ##### Token Balances #####

  " Amount of input token in the market. "
  inputTokenBalance: BigInt!

  " Price per share of input token in USD "
  inputTokenPriceUSD: BigDecimal!

  " Total supply of output token "
  outputTokenSupply: BigInt!

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal!

  " Amount of input token per full share of output token. Only applies when the output token exists "
  exchangeRate: BigDecimal

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

type MarketHourlySnapshot @entity {
  " { Smart contract address of the market }-{ # of hours since Unix epoch time } "
  id: ID!

  " The protocol this snapshot belongs to "
  protocol: LendingProtocol!

  " The pool this snapshot belongs to "
  market: Market!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " All interest rates / fees allowed in the market. Interest rate should be in APY percentage "
  rates: [InterestRate!]!

  " Current TVL (Total Value Locked) of this market "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the market, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the market, accrued to the supply side. "
  hourlySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the market, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the market, accrued to the protocol. "
  hourlyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the market. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Hourly revenue generated by the market. "
  hourlyTotalRevenueUSD: BigDecimal!

  " Current balance of all deposited assets (not historical cumulative), in USD. Same as pool TVL. "
  totalDepositBalanceUSD: BigDecimal!

  " Sum of all deposits made in a given hour, in USD "
  hourlyDepositUSD: BigDecimal!

  " Sum of all historical deposits in USD (only considers deposits and not withdrawals) "
  cumulativeDepositUSD: BigDecimal!

  " Current balance of all borrowed/minted assets (not historical cumulative), in USD. "
  totalBorrowBalanceUSD: BigDecimal!

  " Sum of all borrows/mints made in a given hour, in USD "
  hourlyBorrowUSD: BigDecimal!

  " Sum of all historical borrows/mints in USD (i.e. total loan origination) "
  cumulativeBorrowUSD: BigDecimal!

  " Total assets liquidated in a given hour, in USD. "
  hourlyLiquidateUSD: BigDecimal!

  " Sum of all historical liquidations in USD "
  cumulativeLiquidateUSD: BigDecimal!

  " Total assets withdrawn on a given hour, in USD. "
  hourlyWithdrawUSD: BigDecimal!

  " Total assets repaid on a given hour, in USD. "
  hourlyRepayUSD: BigDecimal!

  ##### Token Balances #####

  " Amount of input token in the market. "
  inputTokenBalance: BigInt!

  " Price per share of input token in USD "
  inputTokenPriceUSD: BigDecimal!

  " Total supply of output token "
  outputTokenSupply: BigInt!

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal!

  " Amount of input token per full share of output token. Only applies when the output token exists "
  exchangeRate: BigDecimal

  " Per-block reward token emission as of the current block normalized to a day (not hour), in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

##############################
##### Account-Level Data #####
##############################

type Account @entity {
  " { Account address } "
  id: ID!

  " Number of positions this account has "
  positionCount: Int!

  " All positions that belong to this account "
  positions: [Position!]! @derivedFrom(field: "account")

  " All open positions this account has "
  openPositions: [Position!]!

  " Number of open positions this account has "
  openPositionCount: Int!

  " Number of closed positions this account has "
  closedPositionCount: Int!

  " Number of deposits this account made "
  depositCount: Int!

  " All deposit events of this account "
  deposits: [Deposit!]! @derivedFrom(field: "account")

  " Number of withdrawals this account made "
  withdrawCount: Int!

  " All withdraw events of this account "
  withdraws: [Withdraw!]! @derivedFrom(field: "account")

  " Number of borrows this account made "
  borrowCount: Int!

  " All borrow events of this account "
  borrows: [Borrow!]! @derivedFrom(field: "account")

  " Number of repays this account made "
  repayCount: Int!

  " All repay events of this account "
  repays: [Repay!]! @derivedFrom(field: "account")

  " Number of times this account liquidated a position "
  liquidateCount: Int!

  " All liquidation events where this account was the liquidator "
  liquidates: [Liquidate!]! @derivedFrom(field: "liquidator")

  " Number of times this account has been liquidated "
  liquidationCount: Int!

  " All liquidation events where this account got liquidated "
  liquidations: [Liquidate!]! @derivedFrom(field: "liquidatee")
}

type Position @entity {
  " { Account address }-{ Market address }-{ Position Side }-{ Counter } "
  id: ID!

  " Account that owns this position "
  account: Account!

  " The market in which this position was opened "
  market: Market!

  " The hash of the transaction that opened this position "
  hashOpened: String!

  " The hash of the transaction that closed this position "
  hashClosed: String

  " Block number of when the position was opened "
  blockNumberOpened: BigInt!

  " Timestamp when the position was opened "
  timestampOpened: BigInt!

  " Block number of when the position was closed (0 if still open) "
  blockNumberClosed: BigInt

  " Timestamp when the position was closed (0 if still open) "
  timestampClosed: BigInt

  " Side of the position (either lender or borrower) "
  side: PositionSide!

  " Whether this position is being used as a collateral (only applies to LENDER positions) "
  isCollateral: Boolean

  " Token balance in this position, in native amounts "
  balance: BigInt!

  " Number of deposits related to this position "
  depositCount: Int!

  " All deposit events of this position "
  deposits: [Deposit!]! @derivedFrom(field: "position")

  " Number of withdrawals related to this position "
  withdrawCount: Int!

  " All withdraw events of this position "
  withdraws: [Withdraw!]! @derivedFrom(field: "position")

  " Number of borrows related to this position "
  borrowCount: Int!

  " All borrow events of this position "
  borrows: [Borrow!]! @derivedFrom(field: "position")

  " Number of repays related to this position "
  repayCount: Int!

  " All repay events of this position "
  repays: [Repay!]! @derivedFrom(field: "position")

  " Number of liquidations related to this position "
  liquidationCount: Int!

  " Liquidation event related to this position (if exists) "
  liquidations: [Liquidate!]! @derivedFrom(field: "position")

  " Position daily snapshots for open positions "
  snapshots: [PositionSnapshot!]! @derivedFrom(field: "position")
}

# Unlike other snapshots that are taken at a fixed time interval. Position
# snapshots should be taken after every event, including the opening and
# closing events. This will prevent an ever growing number of snapshots
# for positions that are not moving. As we are only recording the balance
# in token amounts instead of in USD, this will work well.
# Note that we only take snapshot for open positions
type PositionSnapshot @entity {
  " { Position ID }-{ Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that triggered this snapshot "
  hash: String!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Nonce of the transaction that triggered this snapshot "
  nonce: BigInt!

  " Position of this snapshot "
  position: Position!

  " Token balance in this position, in native amounts "
  balance: BigInt!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

##################################
##### Event-Level Data #####
##################################

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""
type Deposit @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Nonce of the transaction that emitted this event "
  nonce: BigInt!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Account that deposited tokens "
  account: Account!

  " The market tokens are deposited to "
  market: Market!

  " The user position changed by this event "
  position: Position!

  " Token deposited "
  asset: Token!

  " Amount of token deposited in native units "
  amount: BigInt!

  " Amount of token deposited in USD "
  amountUSD: BigDecimal!
}

type Withdraw @entity(immutable: true) {
  " { Transaction hash }-{ Log index }"
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Nonce of the transaction that emitted this event "
  nonce: BigInt!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Account that withdrew tokens "
  account: Account!

  " The market tokens are withdrew from "
  market: Market!

  " The user position changed by this event "
  position: Position!

  " Token withdrawn "
  asset: Token!

  # Certain protocols (e.g. MakerDAO) uses a negative amount for withdraws. You
  # should convert them to positive for consistency.
  # e.g. Event log 27 in https://etherscan.io/tx/0xe957cf6252c7712c218c842c1ade672bf5ce529f8512f7a5ce7ebc8afa4ec690#eventlog

  " Amount of token withdrawn in native units "
  amount: BigInt!

  " Amount of token withdrawn in USD "
  amountUSD: BigDecimal!
}

# For CDPs, use this for mint events
type Borrow @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Nonce of the transaction that emitted this event "
  nonce: BigInt!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Account that borrowed/minted tokens "
  account: Account!

  " The market tokens are borrowed/minted from "
  market: Market!

  " The user position changed by this event "
  position: Position!

  " Token borrowed "
  asset: Token!

  " Amount of token borrowed in native units "
  amount: BigInt!

  " Amount of token borrowed in USD "
  amountUSD: BigDecimal!
}

# For CDPs, use this for burn events
type Repay @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Nonce of the transaction that emitted this event "
  nonce: BigInt!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Account that repaid/burned tokens "
  account: Account!

  " The market tokens are repaid/burned to "
  market: Market!

  " The user position changed by this event "
  position: Position!

  " Token repaid/burned "
  asset: Token!

  " Amount of token repaid/burned in native units "
  amount: BigInt!

  " Amount of token repaid/burned in USD "
  amountUSD: BigDecimal!
}

type Liquidate @entity(immutable: true) {
  " { Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Nonce of the transaction that emitted this event "
  nonce: BigInt!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Account that carried out the liquidation "
  liquidator: Account!

  " Account that got liquidated "
  liquidatee: Account!

  " The market of the collateral being used "
  market: Market!

  " The (borrower) user position changed by this event "
  position: Position!

  " The (lender) user position changed by this event "
  lenderPosition: Position!

  " Asset repaid (borrowed) "
  asset: Token!

  " Amount of collateral liquidated in native units "
  amount: BigInt!

  " Amount of collateral liquidated in USD "
  amountUSD: BigDecimal!

  " Amount of profit from liquidation in USD "
  profitUSD: BigDecimal!
}

# Helper entity for calculating daily/hourly active users
type ActiveAccount @entity {
  " { daily/hourly }-{ Address of the account }-{ Days/hours since Unix epoch } "
  id: ID!
}

#####################################
##### Synthtix specific entities #####
#####################################

type SynthByCurrencyKey @entity {
  " currency key "
  id: ID!
  proxyAddress: Bytes!
}

type Synth @entity {
  " lowercase address of the proxy contract for the synth "
  id: ID!
  name: String!
  symbol: String!
  totalSupply: BigDecimal
}

type SynthBalance @entity {
  " timestamp + account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: String!
  timestamp: BigInt!
  synth: Synth
}

" we dont query these entities but only use it to store aggregate data we need during syncing "
type LatestSynthBalance @entity {
  " account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: String!
  timestamp: BigInt!
  synth: Synth
}

type DelegatedWallet @entity {
  " authoriser-delegate "
  id: ID!
  authoriser: Bytes!
  delegate: Bytes!
  canMint: Boolean
  canBurn: Boolean
  canClaim: Boolean
  canExchange: Boolean
}

type ExchangeEntrySettled @entity {
  " transaction hash and log index "
  id: ID!
  " synth exchanged from "
  from: Bytes!
  " synth exchanged to "
  src: Bytes!
  " number of units of synth from exchanged "
  amount: BigDecimal!
  " address which receives the settlement "
  dest: Bytes!
  " amount reclaimed of dest due to underpayment "
  reclaim: BigDecimal!
  " amount returned of dest due to overpayment "
  rebate: BigDecimal!
  " aggregator price round for src synth "
  srcRoundIdAtPeriodEnd: BigInt!
  " aggregator price round for dest synth "
  destRoundIdAtPeriodEnd: BigInt!
  " time when the original exchange occured "
  exchangeTimestamp: BigInt!
}

type ExchangeEntryAppended @entity {
  " transaction hash and log index "
  id: ID!
  " ethereum address which funded the exchange "
  account: Bytes!
  " synth exchanged from "
  src: Bytes!
  " number of units of synth from exchanged "
  amount: BigDecimal!
  " synth exchanged to "
  dest: Bytes!
  " number of units of synth to received "
  amountReceived: BigDecimal!
  " fee paid in sUSD to the synthetix fee pool "
  exchangeFeeRate: BigDecimal!
  " aggregator price round for src synth "
  roundIdForSrc: BigInt!
  " aggregator price round for dest synth "
  roundIdForDest: BigInt!
}

type TemporaryExchangePartnerTracker @entity {
  " Transaction hash of the Exchange event "
  id: ID!
  " Total transaction volume in USD across all ExchangeEntryAppended events in a single tx hash "
  usdVolume: BigDecimal
  " Total fees from this transaction hash "
  usdFees: BigDecimal
  " String format of the tracking code for a given partner "
  partner: String
}

type DailyExchangePartner @entity {
  " Day timestamp + tracking code of the partner "
  id: ID!
  " Total transaction volume in USD for the partner on this day "
  usdVolume: BigDecimal!
  " Total fees generated by the volume partner for this day "
  usdFees: BigDecimal!
  " Total number of trades from the volume partner for this day "
  trades: BigInt!
  " Tracking code of the partner "
  partner: String!
  " unix timestamp at the beginning of the day "
  timestamp: BigInt!
}

type ExchangePartner @entity {
  " Tracking code of the partner "
  id: ID!
  " Total transaction volume in USD for the partner "
  usdVolume: BigDecimal!
  " Total fees generated by the volume partner "
  usdFees: BigDecimal!
  " Total number of trades from the volume partner "
  trades: BigInt!
}

" we dont query this entity but only use it to store aggregate data we need during syncing "
type InversePricingInfo @entity {
  " Name of inverse synth. E.g. iETH "
  id: ID!
  " whether or not this inverse synth has been frozen "
  frozen: Boolean!
  " configured upper limit "
  upperLimit: BigDecimal!
  " configured lower limit "
  lowerLimit: BigDecimal!
  " matching price point with long synth "
  entryPoint: BigDecimal!
}

type LatestRate @entity {
  " Name of synth. E.g. sUSD "
  id: ID!
  " Synth USD rate "
  rate: BigDecimal!
  " Address of the aggregator which produces current result "
  aggregator: Bytes!
}

" Latest Rates over time "
type RateUpdate @entity {
  " <transaction hash>-<currency key> "
  id: ID!
  " currencyKey for which this this rate update applies "
  currencyKey: Bytes!
  " currencyKey expressed as a string "
  synth: String!
  " the rate recorded at this timestamp "
  rate: BigDecimal!
  " the block which this rate was recorded "
  block: BigInt!
  " timestamp of the block in which the rate was recorded "
  timestamp: BigInt!
}

type DailyCandle @entity {
  id: ID!
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  timestamp: BigInt!
  average: BigDecimal
  period: BigInt
  aggregatedPrices: BigInt
}

" Tracks this event from the Synthetix.sol contract "
type SynthExchange @entity {
  id: ID!
  account: Exchanger!
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  feesInUSD: BigDecimal!
  toAddress: Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
}

" Tracks this event from the Synthetix.sol contract. (Atomic exchanges also trigger standard SynthExchange events.)"
type AtomicSynthExchange @entity {
  id: ID!
  account: Exchanger!
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  feesInUSD: BigDecimal!
  toAddress: Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type ExchangeReclaim @entity {
  id: ID!
  account: Exchanger!
  currencyKey: Bytes!
  amount: BigDecimal!
  amountInUSD: BigDecimal!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type ExchangeRebate @entity {
  id: ID!
  account: Exchanger!
  currencyKey: Bytes!
  amount: BigDecimal!
  amountInUSD: BigDecimal!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

type Total @entity {
  " $timestamp-$period-$bucketMagnitude-$synth "
  id: ID!
  " timestamp of the beginning of the time period this represents "
  timestamp: BigInt!
  " which product the volume came from. Ex 'futures' or 'exchange' "
  product: String
  " number of seconds the data covers after `timestamp` "
  period: BigInt!
  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!
  " synth to filter by "
  synth: Synth
  " number of trades completed over period "
  trades: BigInt!
  " number of unique traders who were first seen in this period "
  newExchangers: BigInt!
  " number of unique traders seen over period "
  exchangers: BigInt!
  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!
  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

" An individual Exchanger aggregated by various time groupings "
type Exchanger @entity {
  " hex address in lowercase (and for non global: hex address in lowercase-$timestamp-$period-$bucketMagnitude-$synth "
  id: ID!
  " timestamp of the beginning of the time period this represents, or 0 for no period filter "
  timestamp: BigInt!
  " number of seconds the data covers after `timestamp`, or 0 for no period filter "
  period: BigInt!
  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!
  " synth to filter by "
  synth: Synth
  " when the user first exchanged "
  firstSeen: BigInt!
  " when the user last exchanged "
  lastSeen: BigInt!
  " nubmer of trades by account "
  trades: BigInt!
  " synth value exchanged in USD units by account "
  exchangeUSDTally: BigDecimal!
  " synth value received in fees in USD units from account "
  totalFeesGeneratedInUSD: BigDecimal!
  " balances "
  balances: [LatestSynthBalance!]
  " exchanges "
  exchanges: [SynthExchange!]! @derivedFrom(field: "account")
}

type ExchangeFee @entity {
  " Name of the synth. E.g. sUSD "
  id: ID!
  " Current Fee as a ratio of the trade amount "
  fee: BigDecimal!
}

type Candle @entity {
  " synth-period-periodId (periodId is timestamp / period) "
  id: ID!
  " Ticker for synth (e.g. 'sUSD') or 'SNX'"
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  average: BigDecimal!
  timestamp: BigInt!
  " Duration this candle captures in seconds. Year, quarter, month, week, day, hour, and 15 minutes available. "
  period: BigInt!
  " Number of RateUpdates aggregated into this candle, mostly useful for the indexer to calculate averages "
  aggregatedPrices: BigInt!
}

" The average price of SNX over a 15 minute period "
type FifteenMinuteSNXPrice @entity {
  " unix timestamp at beginning of 15 minute period "
  id: ID!
  " number of samples averaged in the period "
  count: BigInt!
  " calculated average price of all the samples "
  averagePrice: BigDecimal!
}

" The average price of SNX over a day "
type DailySNXPrice @entity {
  " unix timestamp at beginning of 15 minute period "
  id: ID!
  " number of samples averaged in the period "
  count: BigInt!
  " calculated average price of all the samples "
  averagePrice: BigDecimal!
}

type FuturesMarket @entity {
  " Address of the market "
  id: ID!
  " time at which these values are recorded "
  timestamp: BigInt!
  " representation of total amount of debt issued over time. increases or decreases proportionally whenever synths are minted/burned "
  debtEntry: BigDecimal!
  " current value of all issued synths which this debt pool is responsible for. fluctuates based on the synth breakdown of the system * exchange rates "
  totalIssuedSynths: BigDecimal!
  " totalIssuedSynths / debtEntry - useful for tracking debt over time "
  debtRatio: BigDecimal!
}

" Synthentix is an aggregation entity "
type Synthetix @entity {
  id: ID!
  " number of stakers currently staking "
  issuers: BigInt!
  " number of addresses which hold SNX "
  snxHolders: BigInt!
}

" An individual Issuer "
type Issuer @entity {
  id: ID!
}

" An individual SNX holder (always overridden with their latest information) "
type SNXHolder @entity {
  " address of holder "
  id: ID!
  " last block where an event happened "
  block: BigInt!
  " last time where an event happened "
  timestamp: BigInt!
  " current SNX balance of the holder "
  balanceOf: BigDecimal
  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal
  " SNX which can be spent as of last event "
  transferable: BigDecimal
  initialDebtOwnership: BigInt
  debtEntryAtIndex: BigInt
  " number of claims performed "
  claims: BigInt
  " number of mints performed "
  mints: BigInt
}

" A historical debt tracker "
type DebtSnapshot @entity {
  id: ID!
  " last block where an event happened "
  block: BigInt!
  " last time when an event happened "
  timestamp: BigInt!
  " address for which these statistics are applicable "
  account: Bytes!
  balanceOf: BigDecimal
  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal
  " sUSD of debt as of last event "
  debtBalanceOf: BigDecimal
  " sUSD debt portion a user had at last index "
  initialDebtOwnership: BigDecimal
  " debt entry when `initialDebtOwnership` applies"
  debtEntryAtIndex: BigInt
}

type DailyIssued @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!
  " amount issued "
  value: BigDecimal!
  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

type DailyBurned @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!
  " amount burned "
  value: BigDecimal!
  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

" Tracks this event from various Synth.sol instances "
type Issued @entity {
  id: ID!
  account: Bytes!
  value: BigDecimal!
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Burned tracks this event from various Synth.sol instances "
type Burned @entity {
  id: ID!
  account: Bytes!
  value: BigDecimal!
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

type RewardEscrowHolder @entity {
  " address which holds a rewardescrow "
  id: ID!
  " amount of tokens remaining to be claimed from the escrow "
  balanceOf: BigDecimal!
  " amount of SNX claimed from the escrow "
  vestedBalanceOf: BigDecimal!
}

" Tracks this event from Synthetix.sol "
type FeesClaimed @entity {
  id: ID!
  account: Bytes!
  value: BigDecimal!
  rewards: BigDecimal!
  block: BigInt!
  timestamp: BigInt!
}

type FeePeriod @entity {
  id: ID!
  startTime: BigInt!
  feesToDistribute: BigDecimal!
  feesClaimed: BigDecimal!
  rewardsToDistribute: BigDecimal!
  rewardsClaimed: BigDecimal!
}

type TotalActiveStaker @entity {
  " single value "
  id: ID!
  " number of stakers seen "
  count: BigInt!
}

type TotalDailyActiveStaker @entity {
  " unix timestamp at beginning of day relevant to this statistic "
  id: ID!
  " unix timestamp as a BigInt (so it can be filtered) "
  timestamp: BigInt!
  " number of stakers seen on this day "
  count: BigInt!
}

type ActiveStaker @entity {
  id: ID!
}

type FeeRate @entity {
  " string representing the setting name "
  id: ID!
  setting: String!
  " name of the synth this record applies to, if any "
  synth: String
  " value of the setting "
  rate: BigDecimal!
}

type AccountFlaggedForLiquidation @entity {
  " the deadline plus the staker address "
  id: ID!
  " the address of the staker "
  account: Bytes!
  " liqudation deadline "
  deadline: BigInt!
  " current collateral ratio "
  collateralRatio: BigInt!
  " snx that is liquidatable "
  liquidatableNonEscrowSNX: BigDecimal!
  " total collateral held by the staker including escrow amount "
  collateral: BigDecimal!
}

type AccountRemovedFromLiquidation @entity {
  " the time at which the staker fixed their c-ratio plus the staker address "
  id: ID!
  " the address of the staker "
  account: Bytes!
  " the time at which the staker fixed their c-ratio "
  time: BigInt!
}

type AccountLiquidated @entity {
  id: ID!
  "the liquidated address"
  account: Bytes!
  "the amount of SNX redeemed by the liquidator"
  snxRedeemed: BigDecimal!
  "the amount of sUSD liquidated"
  amountLiquidated: BigDecimal!
  "the address liquidating the account"
  liquidator: Bytes!
  "the time at which the liquidation occurred"
  time: BigInt!
}

type Loan @entity {
  " the loan id "
  id: ID!
  " the transaction hash of the loan "
  txHash: String!
  " the account receiving the loan "
  account: Bytes!
  " the currency of loan amount "
  currency: String
  " the type of collateral minted - sUSD or sETH "
  collateralMinted: String!
  " the amount of the loan "
  amount: BigDecimal!
  " the amount of collateral "
  collateralAmount: BigDecimal
  " is the loan still open? "
  isOpen: Boolean!
  " the timestamp the loan was created "
  createdAt: BigInt!
  " the timestamp the loan was closed "
  closedAt: BigInt
  " whether the loan has any partial liquidations "
  hasPartialLiquidations: Boolean!
}

type LoanLiquidated @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the loan id "
  loanId: BigInt!
  " the account that created the loan "
  account: Bytes!
  " the account that liquidated the loan "
  liquidator: Bytes!
  " the timestamp the loan was liquidated "
  timestamp: BigInt!
}

type LoanPartiallyLiquidated @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the loan id "
  loanId: BigInt!
  " the account that created the loan "
  account: Bytes!
  " the account that partially liquidated the loan "
  liquidator: Bytes!
  " the amount partially liquidated "
  liquidatedAmount: BigDecimal!
  " the amount partially liquidated plus the liquidation fee "
  liquidatedCollateral: BigDecimal!
  " the timestamp the loan was partially liquidated "
  timestamp: BigInt!
}

type CollateralDeposited @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the amount of collateral deposited "
  collateralAmount: BigDecimal!
  " the total amount of collateral after the deposit is included "
  collateralAfter: BigDecimal!
  " the account that created the loan "
  account: Bytes!
  " the loan id "
  loanId: BigInt!
  " the timestamp collateral was deposited "
  timestamp: BigInt!
}

type CollateralWithdrawn @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the amount of collateral withdrawn "
  amountWithdrawn: BigDecimal!
  " the total amount of collateral after the withdrawal is accounted for "
  collateralAfter: BigDecimal!
  " the account that created the loan "
  account: Bytes!
  " the loan id "
  loanId: BigInt!
  " the timestamp collateral was withdrawn "
  timestamp: BigInt!
}

type LoanRepaid @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the amount of the loan that was repaid "
  repaidAmount: BigDecimal!
  " the total amount of the loan after the repaid amount is accounted for "
  newLoanAmount: BigDecimal!
  " the account that created the loan "
  account: Bytes!
  " the loan id "
  loanId: BigInt!
  " the timestamp the loan was partially or fully repaid "
  timestamp: BigInt!
}

type DebtState @entity {
  " Global historical debt entry index "
  id: ID!
  period: BigInt
  " time at which these values are recorded "
  timestamp: BigInt!
  " representation of total amount of debt issued over time. increases or decreases proportionally whenever synths are minted/burned "
  debtEntry: BigDecimal!
  " current value of all issued synths which this debt pool is responsible for. fluctuates based on the synth breakdown of the system * exchange rates "
  totalIssuedSynths: BigDecimal!
  " totalIssuedSynths / debtEntry - useful for tracking debt over time "
  debtRatio: BigDecimal!
}

type SystemSetting @entity {
  id: ID!
  " time at which these values are recorded "
  timestamp: BigInt!
  " SIP-37 Fee Reclamation: The number of seconds after an exchange is executed that must be waited before settlement. "
  waitingPeriodSecs: BigInt!
  " SIP-65 Decentralized Circuit Breaker: The factor amount expressed in decimal format E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below "
  priceDeviationThresholdFactor: BigDecimal!
  " The raio of collateral Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18) "
  issuanceRatio: BigDecimal!
  " How long a fee period lasts at a minimum. It is required for anyone to roll over the periods, so they are not guaranteed to roll over at exactly this duration, but the contract enforces that they cannot roll over any quicker than this duration. "
  feePeriodDuration: BigInt!
  " Users are unable to claim fees if their collateralisation ratio drifts out of target threshold "
  targetThreshold: BigDecimal!
  " SIP-15 Liquidations: liquidation time delay after address flagged (seconds) "
  liquidationDelay: BigInt!
  " SIP-15 Liquidations: issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio when flag means 1/0.5 = 200% cratio "
  liquidationRatio: BigDecimal!
  " SIP-15 Liquidations: penalty taken away from target of liquidation (with 18 decimals). E.g. 10% is 0.1e18 "
  liquidationPenalty: BigDecimal!
  " How long will the ExchangeRates contract assume the rate of any asset is correct "
  rateStalePeriod: BigInt!
  minimumStakeTime: BigInt!
  debtSnapshotStaleTime: BigInt!
  aggregatorWarningFlags: String!
  " SIP 112: ETH Wrappr: The maximum amount of ETH held by the EtherWrapper. "
  etherWrapperMaxETH: BigDecimal!
  " SIP 112: ETH Wrappr: The fee for depositing ETH into the EtherWrapper. "
  etherWrapperMintFeeRate: BigDecimal!
  " SIP 112: ETH Wrappr: The fee for burning sETH and releasing ETH from the EtherWrapper. "
  etherWrapperBurnFeeRate: BigDecimal!
  " SIP-120 Atomic exchanges: max allowed volume per block for atomic exchanges "
  atomicMaxVolumePerBlock: BigInt!
  " SIP-120 Atomic exchanges: time window (in seconds) for TWAP prices when considered for atomic exchanges "
  atomicTwapWindow: BigInt!
}

type Short @entity {
  " the short id "
  id: ID!
  " contract level info for the short position "
  contractData: ShortContract!
  " the transaction hash of the short "
  txHash: String!
  " the account that created the short "
  account: Bytes!
  " the type of collateral locked - sUSD, ETH, renBTC "
  collateralLocked: Bytes!
  " the amount of collateral locked in the short "
  collateralLockedAmount: BigDecimal!
  " the denomination of the loan repayment - sETH, sBTC "
  synthBorrowed: Bytes!
  " the amount owed denominated in the loan repayment synth "
  synthBorrowedAmount: BigDecimal!
  " the timestamp the accrued interest was most recently updated "
  accruedInterestLastUpdateTimestamp: BigInt!
  " is the short still open? "
  isOpen: Boolean!
  " the block the short was created at "
  createdAtBlock: BigInt!
  " the timestamp the short was created "
  createdAt: BigInt!
  " the timestamp the short was closed "
  closedAt: BigInt
  " liquidations that have been made on the short "
  liquidations: [ShortLiquidation!] @derivedFrom(field: "short")
  " collateral deposits and withdrawals that have been made on the short "
  collateralChanges: [ShortCollateralChange!] @derivedFrom(field: "short")
  " loan changes that have been made on the short - increasing or decreasing the short position "
  loanChanges: [ShortLoanChange!]! @derivedFrom(field: "short")
}

type ShortCollateralChange @entity {
  " the event tx hash plus event log index "
  id: ID!
  " denotes if the event was a deposit (true) or withdrawal (false)"
  isDeposit: Boolean!
  " the amount of collateral deposited or withdrawn "
  amount: BigDecimal!
  " the total amount of collateral after the deposit or withdrawal is included "
  collateralAfter: BigDecimal!
  " the respective short "
  short: Short!
  " the timestamp collateral was deposited or withdrawn "
  timestamp: BigInt!
  " the block the collateral was changed "
  blockNumber: BigInt!
}

type ShortLoanChange @entity {
  " the event tx hash plus event log index "
  id: ID!
  " denotes if the event was a repayment (true) or an increase of the loan (false)"
  isRepayment: Boolean!
  " the amount of loan repaid or increased "
  amount: BigDecimal!
  " the total amount of loan due after the repayment or increase is included "
  loanAfter: BigDecimal!
  " the respective short "
  short: Short!
  " the price of the repaid synth in dollars "
  rate: BigDecimal!
  " the timestamp of the loan repayment or increase "
  timestamp: BigInt!
  " the block the short loan was changed "
  blockNumber: BigInt!
}

type ShortLiquidation @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the account that liquidated the loan "
  liquidator: Bytes!
  " determines if the "
  isClosed: Boolean!
  " the amount of the loan that was burned "
  liquidatedAmount: BigDecimal!
  " the amount of the collateral that was taken away from the short owner "
  liquidatedCollateral: BigDecimal!
  " the respective short "
  short: Short!
  " the timestamp of the loan liquidation event "
  timestamp: BigInt!
  " the block of the liquidation event "
  blockNumber: BigInt!
}

type ShortContract @entity {
  " the address of the shorting contract "
  id: ID!
  " a list of shorts attached to each contract "
  shorts: [Short!] @derivedFrom(field: "contractData")
  " a list of changes to contract level data "
  contractUpdates: [ShortContractUpdate!] @derivedFrom(field: "contractData")
  " the min c-ratio for borrowers below which they can be liquidated "
  minCratio: BigInt!
  " the minimum collateral required to open a position "
  minCollateral: BigDecimal!
  " the fee for issuing a short "
  issueFeeRate: BigDecimal!
  " the max number of loans per account "
  maxLoansPerAccount: BigInt!
  " Time in seconds that a user must wait between interacting with a loan. Provides front running and flash loan protection. "
  interactionDelay: BigInt!
  " the manager is a contract that ties the shorting contract in with the rest of the Synthetix protocol "
  manager: Bytes!
  " a boolean that prevents new loans on the contract when false "
  canOpenLoans: Boolean!
}

type ShortContractUpdate @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the field that was changed "
  field: String!
  " the new value of the field in string format "
  value: String!
  " the respective short contract "
  contractData: ShortContract!
  " the timestamp of the contract update event "
  timestamp: BigInt!
  " the block the short contract was udpated at "
  blockNumber: BigInt!
}

type Wrapper @entity {
  " wrapper address "
  id: ID!
  " address of wrapped token, empty if ETH"
  tokenAddress: String!
  " the current amount of synths minted by this wrapper"
  amount: BigDecimal!
  " the current amount of synths minted by this wrapper in USD"
  amountInUSD: BigDecimal!
  " the maximum amount of synths that can be minted by this wrapper"
  maxAmount: BigDecimal!
  " the currency key of this wrapper "
  currencyKey: String!
  " the total amount of fees generated by this wrapper "
  totalFees: BigDecimal!
  " the total amount of fees generated by this wrapper in USD"
  totalFeesInUSD: BigDecimal!
}

type WrapperMint @entity {
  " the transaction hash with a log index appended "
  id: ID!
  " address of the user minting "
  account: String!
  " amount of synth minted "
  principal: BigDecimal!
  " amount of fees collected "
  fee: BigDecimal!
  " total amount added to the wrapper "
  amountIn: BigDecimal!
  " the timestamp of the block that includes this event "
  timestamp: BigInt!
  " the address of the wrapper that minted this synth "
  wrapperAddress: String!
}

type WrapperBurn @entity {
  " the transaction hash with a log index appended "
  id: ID!
  " address of the user burning "
  account: String!
  " amount of synth burned "
  principal: BigDecimal!
  " amount of fees collected "
  fee: BigDecimal!
  " total amount removed from the wrapper "
  amountOut: BigDecimal!
  " the timestamp of the block that includes this event "
  timestamp: BigInt!
  " the address of the wrapper that burned this synth "
  wrapperAddress: String!
}
