# Subgraph Schema: Bridge
# Version: 1.0.0
# See https://github.com/messari/subgraphs/blob/master/docs/SCHEMA.md for details
enum Network {
  ARBITRUM_ONE
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC # aka BNB Chain
  CELO
  COSMOS
  CRONOS
  MAINNET # Ethereum Mainnet
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC # aka Polygon
  XDAI # aka Gnosis Chain
}

enum ProtocolType {
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  GENERIC
  # Will add more
}

enum CrosschainTokenType {
  WRAPPED # Minted by a bridge and backed by a canonical token in other network
  CANONICAL
}

enum BridgePoolType {
  LOCK_RELEASE
  BURN_MINT
  LIQUIDITY
}

enum BridgePermissionType {
  PERMISSIONLESS # anyone can add new tokens to it
  WHITELIST # tokens can be requested to be added and there is some vetting process
  PRIVATE # a centralized party controls the bridge and decides what tokens are added
}

type Token @entity {
  " Smart contract address of the token "
  id: Bytes!

  " Name of the token, mirrored from the smart contract "
  name: String!

  " Symbol of the token, mirrored from the smart contract "
  symbol: String!

  " The number of decimal places this token uses, default to 18 "
  decimals: Int!

  " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal

  " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt
}

# CrosschainToken is the representation of a token from a different chain.
# For example, if you bridge USDC from Ethereum to Polygon, the token on Polygon is a CrosschainToken.
# CrosschainToken might or might not be canonical. It refers to the counterpart of the token on the other chain.
# If the token is wrapped on the current chain, CrosschainToken will be canonical on the opposite chain.
# It might also be the case that both the current chain token and its counterpart are canonical, in the case of liquidity bridges.
type CrosschainToken @entity {
  # We prepend the chainID because it is possible for a token to have the same address on multiple chains.
  # ChainID is the id of the destination chain (not the one the subgraph is running on), and tokenID is the
  # address of the token on the current chain.
  " Bytes.fromI32(chainID).concat(tokenAddress) "
  id: Bytes!

  " The ID commonly used to signal to which chain a transaction is going. List of IDs: https://chainlist.org/ "
  chainID: Int!

  " The network where this token is deployed "
  network: Network!

  " The address on the external chain. It is necessary so we can link pools and routes among chans. "
  address: Bytes!

  " The type of token on the other chain "
  type: CrosschainTokenType!

  " The underlying token on the network where this subgraph running "
  token: Token!
}

enum RewardTokenType {
  " For reward tokens awarded to LPs/lenders "
  DEPOSIT

  " For reward tokens awarded to borrowers "
  BORROW
}

type RewardToken @entity(immutable: true) {
  " Bytes.fromI32(0|1).concat(rewardTokenAddress), where 0 is for deposit and 1 is for borrow "
  id: Bytes!

  " Reference to the actual token "
  token: Token!

  " The type of the reward token "
  type: RewardTokenType!
}

#############################
##### Protocol Metadata #####
#############################

interface Protocol {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: Bytes!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3. It should stay consistent among all deployments. "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, Bridge, etc) "
  type: ProtocolType!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of the entire protocol on this chain. "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. In the case of bridges, revenue only includes that of transactions initiated in this chain "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. In the case of bridges, revenue only includes that of transactions initiated in this chain "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. In the case of bridges, revenue only includes that of transactions initiated in this chain "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Number of cumulative unique addresses that interacted with the contracts on this chain or received funds from other chains "
  cumulativeUniqueUsers: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]!
    @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]!
    @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")

  ##### Pools #####

  " All pools that belong to this protocol "
  pools: [Pool!]! @derivedFrom(field: "protocol")
}

type BridgeProtocol implements Protocol @entity {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: Bytes!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, Bridge, etc) "
  type: ProtocolType!

  " Indicates if the bridge is permissionless, whitelisted, or private. Based on how is the process of adding new tokens to the bridge "
  permissionType: BridgePermissionType!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of the entire protocol on this chain. "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Revenue (originated in this chain) claimed by suppliers to the protocol. Mainly applies to Liquidity bridges. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue (originated in this chain) for the protocol. Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. Includes fees to bridge validators (if any) "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Total revenue (originated in this chain) "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Cumulative USD value of tokens bridged to this chain "
  cumulativeVolumeInUSD: BigDecimal!

  " Cumulative USD value of tokens bridged from this chain "
  cumulativeVolumeOutUSD: BigDecimal!

  " Cumulative USD value of tokens bridged to or from this chain "
  cumulativeTotalVolumeUSD: BigDecimal!

  " Volume in minus volume out "
  netVolumeUSD: BigDecimal!

  " Number of cumulative unique addresses that interacted with the contracts on this chain or received funds from other chains. It should not include senders on other chains "
  cumulativeUniqueUsers: Int!

  " Number of unique addresses that bridged funds out of this chain "
  cumulativeUniqueTransferSenders: Int!

  " Number of unique a addresses that received funds from other chains into this one "
  cumulativeUniqueTransferReceivers: Int!

  " Total number of unique addresses that provided liquidity to the bridge on this chain "
  cumulativeUniqueLiquidityProviders: Int!

  " Total number of unique addresses that sent a message (not funds) through the bridge from this chain "
  cumulativeUniqueMessageSenders: Int!

  " Total number of transactions. Transactions include all entities that implement the Event interface. "
  cumulativeTransactionCount: Int!

  " Total number of transactions transferring funds from this chain "
  cumulativeTransferOutCount: Int!

  " Total number of transactions transferring funds to this chain "
  cumulativeTransferInCount: Int!

  " Total number of deposits providing liquidity to a liquidity based pool "
  cumulativeLiquidityDepositCount: Int!

  " Total number of withdrawals from a liquidity based pool. Refers to withdrawals of liquidity "
  cumulativeLiquidityWithdrawCount: Int!

  " Total number of messages (not transfers) sent through the bridge, originating in this chain "
  cumulativeMessageSentCount: Int!

  " Total number of messages (not transfers) sent through the bridge, received in this chain "
  cumulativeMessageReceivedCount: Int!

  " List of networks supported with which this side of the bridge connects "
  supportedNetworks: [Network!]!

  " Total number of pools. In a bridge, we call a pool the 'vault' where funds are locked/burned or minted/released when sending funds cross chain "
  totalPoolCount: Int!

  " We call a pool route each connection a token has with another chain. For example, if USDC can be bridged from the current chain to 2 others, it will have 2 pool routes. Not all assets can be bridged to all chains. "
  totalPoolRouteCount: Int!

  "  Number of routes where the destination asset is canonical (i.e. it is not wrapped)"
  totalCanonicalRouteCount: Int!

  " Number of routes where the destination asset is a wrapped version of the source asset, usually minted by the bridge contract "
  totalWrappedRouteCount: Int!

  " Total number of tokens that can be bridged from or to this chain. Other tokens supported by the bridge but not on this chain are not counted "
  totalSupportedTokenCount: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]!
    @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]!
    @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")

  ##### Pools #####

  " All pools that belong to this protocol "
  pools: [Pool!]! @derivedFrom(field: "protocol")
}

###############################
##### Protocol Timeseries #####
###############################

type UsageMetricsDailySnapshot @entity {
  " ID is # of days since Unix epoch time (Bytes.fromI32(num)) "
  id: Bytes!

  " Same as the ID, but readable. Number of days since Unix "
  day: Int!

  " Protocol this snapshot is associated with "
  protocol: BridgeProtocol!

  ##### User cumulatives #####
  " Number of cumulative unique addresses that interacted with the contracts on this chain or received funds from other chains. It should not include senders on other chains "
  cumulativeUniqueUsers: Int!

  " Number of unique addresses that bridged funds out of this chain "
  cumulativeUniqueTransferSenders: Int!

  " Number of unique a addresses that received funds from other chains into this one "
  cumulativeUniqueTransferReceivers: Int!

  " Total number of unique addresses that provided liquidity to the bridge "
  cumulativeUniqueLiquidityProviders: Int!

  " Total number of unique addresses that sent a message through the bridge "
  cumulativeUniqueMessageSenders: Int!

  ##### User Daily Acitivty #####
  " Number of unique daily active users "
  dailyActiveUsers: Int!

  " Number of unique addresses that bridged funds out of this chain in the last day "
  dailyActiveTransferSenders: Int!

  " Number of unique addresses that received funds from other chains into this one in the last day "
  dailyActiveTransferReceivers: Int!

  " Number of unique addresses that provided liquidity to the bridge in a day "
  dailyActiveLiquidityProviders: Int!

  " Number of unique addresses that sent a message through the bridge in a day "
  dailyActiveMessageSenders: Int!

  ##### Transaction counts #####
  " Total number of transactions. Transactions include all entities that implement the Event interface. "
  cumulativeTransactionCount: Int!

  " Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. "
  dailyTransactionCount: Int!

  " Total number of transactions transferring funds from this chain "
  cumulativeTransferOutCount: Int!

  " Total number of transactions transferring funds from this chain in a day "
  dailyTransferOutCount: Int!

  " Total number of transactions transferring funds to this chain "
  cumulativeTransferInCount: Int!

  " Total number of transactions transferring funds to this chain in a day "
  dailyTransferInCount: Int!

  " Total number of deposits providing liquidity to a liquidity based pool "
  cumulativeLiquidityDepositCount: Int!

  " Total number of deposits providing liquidity to a liquidity based pool in a day "
  dailyLiquidityDepositCount: Int!

  " Total number of withdrawals from a liquidity based pool. Refers to withdrawals of liquidity "
  cumulativeLiquidityWithdrawCount: Int!

  " Total number of withdrawals from a liquidity based pool in a day "
  dailyLiquidityWithdrawCount: Int!

  " Total number of messages (not transfers) sent through the bridge, originating in this chain "
  cumulativeMessageSentCount: Int!

  " Total number of messages sent through the bridge, originating in this chain in a day"
  dailyMessageSentCount: Int!

  " Total number of messages (not transfers) sent through the bridge, received in this chain "
  cumulativeMessageReceivedCount: Int!

  " Total number of messages sent through the bridge, received in this chain in a day "
  dailyMessageReceivedCount: Int!

  ##### Misc #####
  " Total number of pools "
  totalPoolCount: Int!

  " We call a pool route each connection a token has with another chain. For example, if USDC can be bridged from the current chain to 2 others, it will have 2 pool routes. Not all assets can be bridged to all chains. "
  totalPoolRouteCount: Int!

  "  Number of routes where the destination asset is canonical (i.e. it is not wrapped)"
  totalCanonicalRouteCount: Int!

  " Number of routes where the destination asset is a wrapped version of the source asset, usually minted by the bridge contract "
  totalWrappedRouteCount: Int!

  " Total number of tokens that can be bridged from or to this chain. Other tokens supported by the bridge but not on this chain are not counted "
  totalSupportedTokenCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type UsageMetricsHourlySnapshot @entity {
  " { Bytes.fromI32(num) } # of hours since Unix epoch time "
  id: Bytes!

  " Same as the ID, but readable. Number of hours since Unix "
  hour: Int!

  " Protocol this snapshot is associated with "
  protocol: BridgeProtocol!

  ##### User cumulatives #####
  " Number of cumulative unique addresses that interacted with the contracts on this chain or received funds from other chains. It should not include senders on other chains "
  cumulativeUniqueUsers: Int!

  " Number of unique addresses that bridged funds out of this chain "
  cumulativeUniqueTransferSenders: Int!

  " Number of unique a addresses that received funds from other chains into this one "
  cumulativeUniqueTransferReceivers: Int!

  " Total number of unique addresses that provided liquidity to the bridge "
  cumulativeUniqueLiquidityProviders: Int!

  " Total number of unique addresses that sent a message through the bridge "
  cumulativeUniqueMessageSenders: Int!

  ##### User Hourly Acitivty #####
  " Number of unique hourly active users "
  hourlyActiveUsers: Int!

  " Number of unique addresses that bridged funds out of this chain in the last hour "
  hourlyActiveTransferSenders: Int!

  " Number of unique addresses that received funds from other chains into this one in the last hour "
  hourlyActiveTransferReceivers: Int!

  " Number of unique addresses that provided liquidity to the bridge in an hour "
  hourlyActiveLiquidityProviders: Int!

  " Number of unique addresses that sent a message through the bridge in an hour "
  hourlyActiveMessageSenders: Int!

  ##### Transaction counts #####
  " Total number of transactions. Transactions include all entities that implement the Event interface. "
  cumulativeTransactionCount: Int!

  " Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. "
  hourlyTransactionCount: Int!

  " Total number of transactions transferring funds from this chain "
  cumulativeTransferOutCount: Int!

  " Total number of transactions transferring funds from this chain in an hour "
  hourlyTransferOutCount: Int!

  " Total number of transactions transferring funds to this chain "
  cumulativeTransferInCount: Int!

  " Total number of transactions transferring funds to this chain in an hour "
  hourlyTransferInCount: Int!

  " Total number of deposits providing liquidity to a liquidity based pool "
  cumulativeLiquidityDepositCount: Int!

  " Total number of deposits providing liquidity to a liquidity based pool in an hour "
  hourlyLiquidityDepositCount: Int!

  " Total number of withdrawals from a liquidity based pool. Refers to withdrawals of liquidity "
  cumulativeLiquidityWithdrawCount: Int!

  " Total number of withdrawals from a liquidity based pool in an hour "
  hourlyLiquidityWithdrawCount: Int!

  " Total number of messages (not transfers) sent through the bridge, originating in this chain "
  cumulativeMessageSentCount: Int!

  " Total number of messages sent through the bridge, originating in this chain in an hour"
  hourlyMessageSentCount: Int!

  " Total number of messages (not transfers) sent through the bridge, received in this chain "
  cumulativeMessageReceivedCount: Int!

  " Total number of messages sent through the bridge, received in this chain in an hour "
  hourlyMessageReceivedCount: Int!

  ##### Misc #####
  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type FinancialsDailySnapshot @entity {
  " ID is # of days since Unix epoch time (Bytes.fromI32(num)) "
  id: Bytes!

  " Same as the ID, but readable. Number of days since Unix "
  day: Int!

  " Protocol this snapshot is associated with "
  protocol: BridgeProtocol!

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  ##### Revenues #####

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  dailySupplySideRevenueUSD: BigDecimal!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  dailyTotalRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  ##### Volumes #####

  " USD value of all tokens bridged to this chain in a day "
  dailyVolumeInUSD: BigDecimal!

  " Cumulative USD value of tokens bridged to this chain in a day "
  cumulativeVolumeInUSD: BigDecimal!

  " USD value of all tokens bridged from this chain in a day "
  dailyVolumeOutUSD: BigDecimal!

  " Cumulative USD value of tokens bridged from this chain "
  cumulativeVolumeOutUSD: BigDecimal!

  " Daily volume in minus volume out "
  dailyNetVolumeUSD: BigDecimal!

  " Cumulative volume in minus volume out "
  cumulativeNetVolumeUSD: BigDecimal!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

###########################
##### Pool-Level Data #####
###########################

type Pool @entity {
  " Smart contract address of the pool "
  id: Bytes!

  " The protocol this pool belongs to "
  protocol: BridgeProtocol!

  " Name of the pool (e.g. Curve.fi DAI/USDC/USDT) "
  name: String

  " Symbol of liquidity pool (e.g. 3CRV) "
  symbol: String

  " A unique identifier that can relate multiple pools together. e.g. a common address that they all share. This is useful for pools with multiple input tokens "
  relation: Bytes

  " The type of the pool, determined by the type of the input tokens. "
  type: BridgePoolType!

  " Tokens that can be bridged from and to this pool "
  inputToken: Token!

  " Equivalent to inputTokens but in the other networks "
  destinationTokens: [CrosschainToken!]!

  " Info about pool usage to and from each chain the pool is connected to "
  routes: [PoolRoute!]!

  # Generally protocols accept one or multiple tokens and mint tokens to the depositor to track ownership
  # Some protocols don't mint any tokens to track ownership, in that case outputToken is null.

  " Token that is minted to track ownership of a liquidity position, if the pool is liquidity based. "
  outputToken: Token

  " Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon "
  rewardTokens: [RewardToken!]

  " Creation timestamp "
  createdTimestamp: BigInt!

  " Creation block number "
  createdBlockNumber: BigInt!

  ##### Quantitative Data #####
  " Only for MINT/BURN pools: the current supply of the minted token on this chain. "
  mintSupply: BigInt

  " Amount of input tokens in the pool "
  inputTokenBalance: BigInt!

  " Current TVL (Total Value Locked) of this pool in USD (only applies to LOCK_RELEASE and LIQUIDITY pools)"
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the pool, from transactions originating in this network, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the pool, from transactions originating in this network, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Total volume bridged to this pool in token amounts "
  cumulativeVolumeIn: BigInt!

  " Total volume bridged from this pool in token amounts "
  cumulativeVolumeOut: BigInt!

  " cumulativeIn - cumulativeOut "
  netVolume: BigInt!

  " Total volume bridged to this pool in USD "
  cumulativeVolumeInUSD: BigDecimal!

  " Total volume bridged from this pool in USD "
  cumulativeVolumeOutUSD: BigDecimal!

  " cumulativeInUSD - cumulativeOutUSD "
  netVolumeUSD: BigDecimal!

  " Total supply of output token. "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]

  ##### Snapshots #####

  " Pool daily snapshots "
  dailySnapshots: [PoolDailySnapshot!]! @derivedFrom(field: "pool")

  " Pool hourly snapshots "
  hourlySnapshots: [PoolHourlySnapshot!]! @derivedFrom(field: "pool")
}

type PoolRoute @entity {
  " Bytes.fromUTF(({Pool ID}-{lowerChainID}-{greaterChainID}) "
  id: Bytes!

  " Pool this route belongs to "
  pool: Pool!

  " A route connects the pool on this chain to its homologous on the other chain, this field refers to the type of the pool on the other chain. "
  counterType: BridgePoolType

  " The token sent or received on the current chain "
  inputToken: Token!

  " The token sent or received on the opposite chain "
  crossToken: CrosschainToken!

  " Indicates if the route contains two different tokens that can be swapped while bridging "
  isSwap: Boolean!

  " total volume received through this route in inputToken "
  cumulativeVolumeIn: BigInt!

  " total volume sent through this route in inputToken "
  cumulativeVolumeOut: BigInt!

  " total volume received through this route in USD "
  cumulativeVolumeInUSD: BigDecimal!

  " total volume sent through this route in USD "
  cumulativeVolumeOutUSD: BigDecimal!

  " Timestamp in which this route is created or first time used "
  createdTimestamp: BigInt!

  " Block number in which this route is created or first time used "
  createdBlockNumber: BigInt!
}

type PoolDailySnapshot @entity {
  " poolAddress.concatI32(daysSinceUnix) "
  id: Bytes!

  " Number of days since Unix "
  day: Int!

  " The protocol this snapshot belongs to "
  protocol: BridgeProtocol!

  " The pool this snapshot belongs to "
  pool: Pool!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Daily revenue generated by the pool, accrued to the supply side. "
  dailySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Daily revenue generated by the pool, accrued to the protocol. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Daily revenue generated by the pool. "
  dailyTotalRevenueUSD: BigDecimal!

  ##### Volumes #####"
  cumulativeVolumeIn: BigInt!
  dailyVolumeIn: BigInt!
  cumulativeVolumeInUSD: BigDecimal!
  dailyVolumeInUSD: BigDecimal!

  cumulativeVolumeOut: BigInt!
  dailyVolumeOut: BigInt!
  cumulativeVolumeOutUSD: BigDecimal!
  dailyVolumeOutUSD: BigDecimal!

  netCumulativeVolume: BigInt!
  netCumulativeVolumeUSD: BigDecimal!
  netDailyVolume: BigInt!
  netDailyVolumeUSD: BigDecimal!

  routes: [PoolRouteSnapshot!]!

  " Only for MINT/BURN pools: the current supply of the minted token. "
  mintSupply: BigInt

  " Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. "
  inputTokenBalance: BigInt!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

type PoolHourlySnapshot @entity {
  " poolAddress.concatI32(hoursSinceUnix) "
  id: Bytes!

  " Same as the ID, but readable. Number of hours since Unix "
  hour: Int!

  " The protocol this snapshot belongs to "
  protocol: BridgeProtocol!

  " The pool this snapshot belongs to "
  pool: Pool!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the pool, accrued to the supply side. "
  hourlySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the pool, accrued to the protocol. "
  hourlyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Hourly revenue generated by the pool. "
  hourlyTotalRevenueUSD: BigDecimal!

  ##### Volumes #####"
  cumulativeVolumeIn: BigInt!
  hourlyVolumeIn: BigInt!
  cumulativeVolumeInUSD: BigDecimal!
  hourlyVolumeInUSD: BigDecimal!

  cumulativeVolumeOut: BigInt!
  hourlyVolumeOut: BigInt!
  cumulativeVolumeOutUSD: BigDecimal!
  hourlyVolumeOutUSD: BigDecimal!

  netCumulativeVolume: BigInt!
  netCumulativeVolumeUSD: BigDecimal!
  netHourlyVolume: BigInt!
  netHourlyVolumeUSD: BigDecimal!

  routes: [PoolRouteSnapshot!]!

  " Only for MINT/BURN pools: the current supply of the minted token. "
  mintSupply: BigInt

  " Amount of input tokens in the pool. The ordering should be the same as the pool's `inputTokens` field. "
  inputTokenBalance: BigInt!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day (not hour), in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

type PoolRouteSnapshot @entity {
  " poolRouteID.concat(poolSnapshotID) "
  id: Bytes!

  " PoolRoute this snapshot belongs to "
  poolRoute: PoolRoute!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " volume received through this route during the time of the snapshot period (hourly/daily) "
  snapshotVolumeIn: BigInt!

  " total volume received through this route in inputToken "
  cumulativeVolumeIn: BigInt!

  " volume sent through this route during the time of the snapshot period (hourly/daily) "
  snapshotVolumeOut: BigInt!

  " total volume sent through this route in inputToken "
  cumulativeVolumeOut: BigInt!

  " volume received through this route during the time of the snapshot period (hourly/daily) in USD "
  snapshotVolumeInUSD: BigDecimal!

  " total volume received through this route in USD "
  cumulativeVolumeInUSD: BigDecimal!

  " volume sent through this route during the time of the snapshot period (hourly/daily) in USD "
  snapshotVolumeOutUSD: BigDecimal!

  " total volume sent through this route in USD "
  cumulativeVolumeOutUSD: BigDecimal!
}

##################################
##### Transaction-Level Data #####
##################################

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""
interface Event {
  " event.transaction.hash.concatI32(event.logIndex) "
  id: Bytes!

  " Transaction hash of the transaction that emitted this event "
  hash: Bytes!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: BridgeProtocol!

  " Address that received the tokens "
  to: Bytes!

  " Address that sent the tokens "
  from: Bytes!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!
}

type LiquidityDeposit implements Event @entity(immutable: true) {
  " event.transaction.hash.concatI32(event.logIndex) "
  id: Bytes!

  " Transaction hash of the transaction that emitted this event "
  hash: Bytes!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: BridgeProtocol!

  " Account owner of this liquidity position. Should match the address in `from` "
  account: Account!

  " Address that received the tokens "
  to: Bytes!

  " Address that sent the tokens "
  from: Bytes!

  " Pool where the tokens are deposited "
  pool: Pool!

  " Token deposited in the pool "
  token: Token!

  " Amount of token deposited "
  amount: BigInt!

  " Amount of token deposited in USD "
  amountUSD: BigDecimal!

  " Id of the chain where this is ocurring (should always be the chain where the subgraph is running) "
  chainID: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!
}

type LiquidityWithdraw implements Event @entity(immutable: true) {
  " event.transaction.hash.concatI32(event.logIndex) "
  id: Bytes!

  " Transaction hash of the transaction that emitted this event "
  hash: Bytes!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: BridgeProtocol!

  " Account owner of this liquidity position. Should match the address in `to` "
  account: Account!

  " Address that received the tokens "
  to: Bytes!

  " Address that sent the tokens "
  from: Bytes!

  " Pool where the tokens are withdrawn from "
  pool: Pool!

  " Token withdrawn from the pool "
  token: Token!

  " Amount of token withdrawn "
  amount: BigInt!

  " Amount of token withdrawn in USD "
  amountUSD: BigDecimal!

  " Id of the chain where this is ocurring (should always be the chain where the subgraph is running) "
  chainID: Int!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!
}

enum TransferType {
  MINT
  BURN
  LOCK
  RELEASE
}

type BridgeTransfer implements Event @entity(immutable: true) {
  " event.transaction.hash.concatI32(event.logIndex) "
  id: Bytes!

  " Transaction hash of the transaction that emitted this event "
  hash: Bytes!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: BridgeProtocol!

  " Account that sent or received the transfer. Should match with either transferFrom or transferTo "
  account: Account!

  " Address that received the tokens "
  to: Bytes!

  " Address that sent the tokens "
  from: Bytes!

  " Are we briding in or out? "
  isOutgoing: Boolean!

  " Chain ID from where the transfer is being sent "
  fromChainID: Int!

  " Chain ID where the transfer is being sent to "
  toChainID: Int!

  " This is the address that's receiving the bridged funds (not a pool contract). When bridging out, it will be the address on the destination chain. "
  transferTo: Bytes!

  " This is the address initiating the transfer, where the initial funds came from. It might not match the address initiating the actual EVM transaction. "
  transferFrom: Bytes

  " Indicates how this transfer is ocurring on the current chain "
  type: TransferType!

  " The pool where the transfer originated or arrived "
  pool: Pool!

  " The route through which the funds where sent or received "
  route: PoolRoute!

  " The token sent/received in this transfer on the current chain "
  token: Token!

  " Amount of token transferred "
  amount: BigInt!

  " Amount of token transferred in USD "
  amountUSD: BigDecimal!

  " The equivalent of our token in the other chain "
  crosschainToken: CrosschainToken!

  " Indicates is the transfer involved a swap while bridging "
  isSwap: Boolean!

  " The transaction ID on the other chain, if available "
  crossTransactionID: Bytes

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!
}

# Some bridges support sending
type BridgeMessage implements Event @entity(immutable: true) {
  " event.transaction.hash.concatI32(event.logIndex) "
  id: Bytes!

  " Transaction hash of the transaction that emitted this event "
  hash: Bytes!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: BridgeProtocol!

  " Account that sent or received the message. Should match with either transferFrom or transferTo "
  account: Account!

  " Address that received the tokens "
  to: Bytes!

  " Address that sent the tokens "
  from: Bytes!

  " Is it an ougoing message to some other chain or incoming instead? "
  isOutgoing: Boolean!

  " Chain ID from where the message is being sent "
  fromChainID: Int!

  " Chain ID where the message is being sent to "
  toChainID: Int!

  " Address sending the message. Here if it is outgoing, or on the other chain if incoming "
  transferFrom: Bytes

  " Address receiving the message. Here if it is incoming, or on the other chain if outgoing "
  transferTo: Bytes

  " Contents of the message "
  data: Bytes!

  " The transaction ID on the other chain, if available "
  crossTransactionID: Bytes

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!
}

# An account is a unique Ethereum address
# Helps to accumulate total unique users
type Account @entity {
  " Address of the account "
  id: Bytes!

  " ChainIDs where this account has sent or received funds through this bridge "
  chains: [Int!]!

  " Total number of transactions this account has sent through this bridge originating from this chain "
  transferOutCount: Int!

  " Total number of transactions this account has received through this bridge originating on other chains "
  transferInCount: Int!

  " All transfer events for this account "
  transfers: [BridgeTransfer!]! @derivedFrom(field: "account")

  " Total number of liquidity deposits this account has made "
  depositCount: Int!

  " All deposit events for this account "
  deposits: [LiquidityDeposit!]! @derivedFrom(field: "account")

  " Total number of liquidity withdrawals this account has made "
  withdrawCount: Int!

  " All withdraw events for this account "
  withdraws: [LiquidityWithdraw!]! @derivedFrom(field: "account")

  " Total number of messages this account has sent through this bridge "
  messageSentCount: Int!

  " Total number of messages this account has received through this bridge "
  messageReceivedCount: Int!

  " All message events for this account "
  messages: [BridgeMessage!]! @derivedFrom(field: "account")
}

# Helper entity for calculating daily/hourly active users
type ActiveAccount @entity(immutable: true) {
  " Bytes.fromUTF( {Address}-{daily|hourly}-{# of day/hour}-{deposit|withdraw|transferIn|transferOut|message} ) "
  id: Bytes!
}
